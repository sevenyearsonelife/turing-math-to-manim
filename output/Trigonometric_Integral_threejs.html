<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trigonometric Integral Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #e0e0e0;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 400px;
        }
        #info h1 {
            color: #6ee7b7;
            font-size: 1.4em;
            margin-bottom: 10px;
        }
        #info .equation {
            background: #2d2d4a;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.1em;
            color: #fbbf24;
            text-align: center;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #e0e0e0;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
        }
        #controls label { display: block; margin: 8px 0; }
        #controls input[type="range"] { width: 200px; }
        #controls .value {
            color: #6ee7b7;
            font-weight: bold;
            min-width: 50px;
            display: inline-block;
        }
        #result {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #e0e0e0;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            text-align: right;
        }
        #result .computed {
            color: #a78bfa;
            font-size: 1.3em;
            font-weight: bold;
        }
        button {
            background: #6ee7b7;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-weight: bold;
        }
        button:hover { background: #34d399; }
    </style>
</head>
<body>
    <div id="info">
        <h1>∫ Trigonometric Integral</h1>
        <div class="equation">
            ∫₀^(π/2) x·sin(2x) / [(1+a·sin²x)(1+b·cos²x)] dx
        </div>
        <p style="margin-top: 10px; font-size: 0.9em; color: #9ca3af;">
            Visualizing how the integrand surface changes with parameters a and b.
            The closed-form solution involves logarithms and square roots.
        </p>
    </div>

    <div id="controls">
        <label>
            Parameter a: <span class="value" id="aVal">1.00</span>
            <br><input type="range" id="aSlider" min="0.1" max="3" step="0.1" value="1">
        </label>
        <label>
            Parameter b: <span class="value" id="bVal">1.00</span>
            <br><input type="range" id="bSlider" min="0.1" max="3" step="0.1" value="1">
        </label>
        <div style="margin-top: 10px;">
            <button id="playBtn">▶ Animate</button>
            <button id="resetBtn">↺ Reset</button>
        </div>
    </div>

    <div id="result">
        <div>Closed Form Result:</div>
        <div class="computed" id="closedForm">0.2854</div>
        <div style="margin-top: 10px; font-size: 0.8em; color: #9ca3af;">
            π/(a+b+ab) · log(√(1+a)(1+√(1+b))/(1+√(1+a)))
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(4, 3, 4);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0x6ee7b7, 1, 100);
        pointLight.position.set(-5, 5, -5);
        scene.add(pointLight);

        // Grid helper
        const gridHelper = new THREE.GridHelper(6, 20, 0x444466, 0x333355);
        gridHelper.position.y = -0.5;
        scene.add(gridHelper);

        // Axes helper
        const axesHelper = new THREE.AxesHelper(3);
        scene.add(axesHelper);

        // Parameters
        let a = 1.0, b = 1.0;

        // The integrand function
        function integrand(x, a, b) {
            const sin2x = Math.sin(2 * x);
            const sin2 = Math.sin(x) ** 2;
            const cos2 = Math.cos(x) ** 2;
            return (x * sin2x) / ((1 + a * sin2) * (1 + b * cos2));
        }

        // Closed form result
        function closedForm(a, b) {
            const denom = a + b + a * b;
            const sqrt1a = Math.sqrt(1 + a);
            const sqrt1b = Math.sqrt(1 + b);
            const num = sqrt1a * (1 + sqrt1b);
            const den = 1 + sqrt1a;
            return (Math.PI / denom) * Math.log(num / den);
        }

        // Create surface geometry
        function createSurface(a, b) {
            const resolution = 50;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const indices = [];

            const xMin = 0, xMax = Math.PI / 2;
            const yMin = 0.1, yMax = 2;

            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution; j++) {
                    const x = xMin + (xMax - xMin) * (i / resolution);
                    const y = yMin + (yMax - yMin) * (j / resolution);
                    const z = integrand(x, y, b);

                    // Scale for visualization
                    vertices.push(
                        (x / (Math.PI / 2)) * 2 - 1,  // x: -1 to 1
                        z * 2,                          // height
                        (y / 2) * 2 - 1                 // z: -1 to 1
                    );

                    // Color based on height
                    const hue = 0.6 - z * 0.4; // Blue to red
                    const color = new THREE.Color().setHSL(hue, 0.8, 0.5);
                    colors.push(color.r, color.g, color.b);
                }
            }

            // Create indices for triangles
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const a = i * (resolution + 1) + j;
                    const b = a + 1;
                    const c = a + (resolution + 1);
                    const d = c + 1;

                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            return geometry;
        }

        // Surface mesh
        let surfaceMesh;
        function updateSurface() {
            if (surfaceMesh) scene.remove(surfaceMesh);

            const geometry = createSurface(a, b);
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                shininess: 50,
                transparent: true,
                opacity: 0.9
            });

            surfaceMesh = new THREE.Mesh(geometry, material);
            scene.add(surfaceMesh);

            // Update closed form display
            const result = closedForm(a, b);
            document.getElementById('closedForm').textContent = result.toFixed(4);
        }

        // Integration path (curve at current a value)
        let pathLine;
        function updatePath() {
            if (pathLine) scene.remove(pathLine);

            const points = [];
            const numPoints = 100;

            for (let i = 0; i <= numPoints; i++) {
                const x = (Math.PI / 2) * (i / numPoints);
                const z = integrand(x, a, b);
                points.push(new THREE.Vector3(
                    (x / (Math.PI / 2)) * 2 - 1,
                    z * 2 + 0.01,
                    (a / 2) * 2 - 1
                ));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x22c55e,
                linewidth: 3
            });

            pathLine = new THREE.Line(geometry, material);
            scene.add(pathLine);
        }

        // Initialize
        updateSurface();
        updatePath();

        // Event listeners
        document.getElementById('aSlider').addEventListener('input', (e) => {
            a = parseFloat(e.target.value);
            document.getElementById('aVal').textContent = a.toFixed(2);
            updateSurface();
            updatePath();
        });

        document.getElementById('bSlider').addEventListener('input', (e) => {
            b = parseFloat(e.target.value);
            document.getElementById('bVal').textContent = b.toFixed(2);
            updateSurface();
            updatePath();
        });

        // Animation
        let animating = false;
        let animTime = 0;

        document.getElementById('playBtn').addEventListener('click', () => {
            animating = !animating;
            document.getElementById('playBtn').textContent = animating ? '⏸ Pause' : '▶ Animate';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            a = 1; b = 1;
            document.getElementById('aSlider').value = 1;
            document.getElementById('bSlider').value = 1;
            document.getElementById('aVal').textContent = '1.00';
            document.getElementById('bVal').textContent = '1.00';
            updateSurface();
            updatePath();
        });

        // Render loop
        function animate() {
            requestAnimationFrame(animate);

            if (animating) {
                animTime += 0.02;
                a = 1 + Math.sin(animTime) * 0.8;
                b = 1 + Math.cos(animTime * 0.7) * 0.8;

                document.getElementById('aSlider').value = a;
                document.getElementById('bSlider').value = b;
                document.getElementById('aVal').textContent = a.toFixed(2);
                document.getElementById('bVal').textContent = b.toFixed(2);

                updateSurface();
                updatePath();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
